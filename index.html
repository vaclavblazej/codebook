<!doctype html><html lang=en-us><head><meta name=generator content="Hugo 0.119.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>The Book of Code</title><meta name=title content="The Book of Code"><meta name=description content><meta name=keywords content><meta property="og:title" content="The Book of Code"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://vaclavblazej.github.io/codebook/"><meta name=twitter:card content="summary"><meta name=twitter:title content="The Book of Code"><meta name=twitter:description content><meta itemprop=name content="The Book of Code"><meta itemprop=description content><meta name=referrer content="no-referrer-when-downgrade"><link href=/codebook/bundle.min.css rel=stylesheet><link rel=alternate type=application/rss+xml href=/codebook/index.xml title="The Book of Code"><script>window.MathJax={tex:{inlineMath:[["$","$"]],displayMath:[["\\[","\\]"]],processEscapes:!0,autoload:{color:[],colorv2:["color"]},packages:{"[+]":["noerrors"]}},options:{ignoreHtmlClass:"tex2jax_ignore",processHtmlClass:"tex2jax_process",renderActions:{addMenu:[0,"",""]}},loader:{load:["[tex]/noerrors"]}}</script><script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js id=MathJax-script></script></head><body><header><nav></nav><h1>The Book of Code</h1></header><main><p>This text is a quick competitive programming reference for <code>c++</code> coders.
The most useful material is contained here.
<a href>Follow links</a> to see discussion, examples, and references.</p><p>Preparation checklist:
<a href=about>about this document & basic terminology</a>,
<a href=comprog>competitive programming</a>,
<a href=language>coding language & style</a>,
<a href=setup>coding environment</a>,
<a href=template>custom template</a>,
<a href=io>input & output</a>,
<a href=run>compiling & running</a>,
<a href=checklist>problemsolving checklist</a>,
<a href=techniques>common techniques</a>.</p><hr><p>The following <a href=template>template</a> is assumed in all of the codes within this book.</p><p>template.h,template</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> ll;
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>double</span> ld;</span></span></code></pre></div><h3 id=c-standard-library-data-structures>C++ standard library data structures</h3><tt><table><tr><th>structure</th><th>operation</th><th>returns</th><th>complexity</th><th>note</th></tr><tr><td>vector&lt;V></td><td colspan=4>dynamically-resizable array, fast element access</td></tr><tr><td></td><td>assign(len,def)</td><td>V</td><td>len</td><td></td></tr><tr><td></td><td>operator[idx]</td><td>V</td><td>$O(1)$</td><td></td></tr><tr><td></td><td>push_back(V)</td><td>--</td><td>$O'(1)$ amortized</td><td></td></tr><tr><td></td><td>pop_back()</td><td>--</td><td>$O(1)$</td><td></td></tr><tr><td></td><td>back()</td><td>V</td><td>$O(1)$</td><td></td></tr><tr><td></td><td>reserve(size)</td><td>--</td><td>size</td><td></td></tr><tr><td></td><td>resize(size,def)</td><td>--</td><td>size</td><td></td></tr><tr><td>set&lt;V></td><td colspan=4>collection of unique keys, iterable by sorted keys</td></tr><tr><td></td><td>insert(V)</td><td>pair<it,ok></td><td>$O(\log N)$</td><td>was inserted?</td></tr><tr><td></td><td>find(V)</td><td>it</td><td>$O(\log N)$</td><td>not found => end</td></tr><tr><td></td><td>lower_bound(V)</td><td>it</td><td>$O(\log N)$</td><td>finds first $\ge$</td></tr><tr><td></td><td>upper_bound(V)</td><td>it</td><td>$O(\log N)$</td><td>finds first $>$</td></tr><tr><td></td><td>count(V)</td><td>#found</td><td>$O(\log N)$</td><td>#found = 0 or 1</td></tr><tr><td></td><td>erase(V)</td><td>#erased</td><td>$O(\log N)$</td><td>#erased = 0 or 1</td></tr><tr><td></td><td>erase(it)</td><td>next it</td><td>$O(\log N)$</td><td></td></tr><tr><td>multiset&lt;V></td><td colspan=4>collection of keys, iterable by sorted keys, has all tde same operations as set<v>, but all behave slightly differently</td><tr><tr><td>unordered_set&lt;V>, unordered_multiset</td><td colspan=4>variants which use hash_tables instead of search trees, tdis makes operations faster $O(1)$, but disables sorted iterating; there is no find, lower_bound, upper_bound</td><tr><tr><td>map&lt;K,V></td><td colspan=4>key-value pairs, unique keys, iterable by sorted keys</td></tr><tr><td></td><td>operator[K]</td><td>V</td><td>$O(\log N)$</td><td>creates nonexistent</td></tr><tr><td></td><td>find(K)</td><td>it</td><td>$O(\log N)$</td><td>find | end</td></tr><tr><td></td><td>lower_bound(V)</td><td>it</td><td>$O(\log N)$</td><td>find first $\ge$</td></tr><tr><td></td><td>upper_bound(V)</td><td>it</td><td>$O(\log N)$</td><td>find first $>$</td></tr><tr><td></td><td>count(V)</td><td>#found</td><td>$O(\log N)$</td><td>#found = 0 or 1</td></tr><tr><td></td><td>erase(V)</td><td>#erased</td><td>$O(\log N)$</td><td>#erased = 0 or 1</td></tr><tr><td></td><td>erase(it)</td><td>next it</td><td>$O(\log N)$</td><td></td></tr><tr><td>multimap&lt;K,V></td><td colspan=4>key-value pairs, iterable by sorted keys, has all the same operations as set<v>, but all behave slightly differently</td><tr><tr><td>unordered_map&lt;V>, unordered_multimap</td><td colspan=4>variants which use hash_tables instead of search trees, this makes operations faster $O(1)$, but disables sorted iterating; there is no find, lower_bound, upper_bound</td><tr><tr><td>deque&lt;V></td><td colspan=4>double-ended queue, quick access to beginning and end}</td></tr><tr><td></td><td>push_front(V)</td><td>--</td><td>$O(1)$</td><td></td></tr><tr><td></td><td>front()</td><td>V</td><td>$O(1)$</td><td></td></tr><tr><td></td><td>pop_front()</td><td>--</td><td>$O(1)$</td><td></td></tr><tr><td></td><td>push_back(V)</td><td>--</td><td>$O(1)$</td><td></td></tr><tr><td></td><td>back()</td><td>V</td><td>$O(1)$</td><td></td></tr><tr><td></td><td>pop_back()</td><td>--</td><td>$O(1)$</td><td></td></tr><tr><td>queue&lt;V></td><td colspan=4>first in first out, (is a deque wrapper)</td></tr><tr><td></td><td>push(V)</td><td>--</td><td>$O(1)$</td><td>= push_back()</td></tr><tr><td></td><td>front()</td><td>V</td><td>$O(1)$</td><td></td></tr><tr><td></td><td>back()</td><td>V</td><td>$O(1)$</td><td></td></tr><tr><td></td><td>pop()</td><td>--</td><td>$O(1)$</td><td>= pop_front()</td></tr><tr><td>stack&lt;V></td><td colspan=4>last in first out, (is a deque wrapper)</td></tr><tr><td></td><td>push(V)</td><td>--</td><td>$O(1)$</td><td>= push_back()</td></tr><tr><td></td><td>top()</td><td>V</td><td>$O(1)$</td><td>= back()</td></tr><tr><td></td><td>pop()</td><td>--</td><td>$O(1)$</td><td>= pop_back()</td></tr><tr><td>priority_queue&lt;V></td><td colspan=4>constant time lookup of the largest element</td></tr><tr><td></td><td colspan=4>minimal pq = priority_queue&lt;V,vector&lt;V>,greater&lt;V>></td></tr><tr><td></td><td>push(V)</td><td>--</td><td>$O(\log N)$</td><td></td></tr><tr><td></td><td>top()</td><td>V</td><td>$O(1)$</td><td></td></tr><tr><td></td><td>pop()</td><td>--</td><td>$O(\log N)$</td><td></td></tr></table></tt><p>Most of the above structures support the following functions.</p><ul><li>number of elements: <code>empty()</code>, <code>size()</code>,</li><li>iterators: <code>begin()</code>, <code>end()</code>, <code>rbegin()</code>, <code>rend()</code>,</li><li>reseting the structure: <code>clear()</code>,</li></ul><p>Beware of using <code>lower_bound</code> and <code>upper_bound</code> on iterators &ndash; it takes $O(N)$ time!</p><p>Structures as <code>set</code>, <code>map</code>, and function <code>sort</code> uses <code>bool operator&lt;(const S &amp;s)const</code> to compare elements.</p><p>You don&rsquo;t need <code>array</code> (use global arrays instead) nor <code>list</code> (use <code>vector</code> or <code>deque</code>).</p><h3 id=ascii-table>Ascii Table</h3><div class=multicols><div class=col50><table><thead><tr><th>num</th><th>binary</th><th>meaning</th><th>num</th><th>binary</th><th>meaning</th></tr></thead><tbody><tr><td>0</td><td>00000000</td><td>(NULL)</td><td>32</td><td>00100000</td><td><code>Space</code></td></tr><tr><td>1</td><td>00000001</td><td>(&ndash;)</td><td>33</td><td>00100001</td><td><code>!</code></td></tr><tr><td>2</td><td>00000010</td><td>(&ndash;)</td><td>34</td><td>00100010</td><td><code>"</code></td></tr><tr><td>3</td><td>00000011</td><td>(&ndash;)</td><td>35</td><td>00100011</td><td><code>#</code></td></tr><tr><td>4</td><td>00000100</td><td>(&ndash;)</td><td>36</td><td>00100100</td><td><code>$</code></td></tr><tr><td>5</td><td>00000101</td><td>(&ndash;)</td><td>37</td><td>00100101</td><td><code>%</code></td></tr><tr><td>6</td><td>00000110</td><td>(&ndash;)</td><td>38</td><td>00100110</td><td><code>&</code></td></tr><tr><td>7</td><td>00000111</td><td>(&ndash;)</td><td>39</td><td>00100111</td><td><code>'</code></td></tr><tr><td>8</td><td>00001000</td><td>(backspace)</td><td>40</td><td>00101000</td><td><code>(</code></td></tr><tr><td>9</td><td>00001001</td><td>(hor. tab)</td><td>41</td><td>00101001</td><td><code>)</code></td></tr><tr><td>10</td><td>00001010</td><td>(LF)</td><td>42</td><td>00101010</td><td><code>*</code></td></tr><tr><td>11</td><td>00001011</td><td>(ver. tab)</td><td>43</td><td>00101011</td><td><code>+</code></td></tr><tr><td>12</td><td>00001100</td><td>(new page)</td><td>44</td><td>00101100</td><td><code>,</code></td></tr><tr><td>13</td><td>00001101</td><td>(CR)</td><td>45</td><td>00101101</td><td><code>-</code></td></tr><tr><td>14</td><td>00001110</td><td>(&ndash;)</td><td>46</td><td>00101110</td><td><code>.</code></td></tr><tr><td>15</td><td>00001111</td><td>(&ndash;)</td><td>47</td><td>00101111</td><td><code>/</code></td></tr><tr><td>16</td><td>00010000</td><td>(&ndash;)</td><td>48</td><td>00110000</td><td><code>0</code></td></tr><tr><td>17</td><td>00010001</td><td>(&ndash;)</td><td>49</td><td>00110001</td><td><code>1</code></td></tr><tr><td>18</td><td>00010010</td><td>(&ndash;)</td><td>50</td><td>00110010</td><td><code>2</code></td></tr><tr><td>19</td><td>00010011</td><td>(&ndash;)</td><td>51</td><td>00110011</td><td><code>3</code></td></tr><tr><td>20</td><td>00010100</td><td>(&ndash;)</td><td>52</td><td>00110100</td><td><code>4</code></td></tr><tr><td>21</td><td>00010101</td><td>(&ndash;)</td><td>53</td><td>00110101</td><td><code>5</code></td></tr><tr><td>22</td><td>00010110</td><td>(&ndash;)</td><td>54</td><td>00110110</td><td><code>6</code></td></tr><tr><td>23</td><td>00010111</td><td>(&ndash;)</td><td>55</td><td>00110111</td><td><code>7</code></td></tr><tr><td>24</td><td>00011000</td><td>(&ndash;)</td><td>56</td><td>00111000</td><td><code>8</code></td></tr><tr><td>25</td><td>00011001</td><td>(&ndash;)</td><td>57</td><td>00111001</td><td><code>9</code></td></tr><tr><td>26</td><td>00011010</td><td>(&ndash;)</td><td>58</td><td>00111010</td><td><code>:</code></td></tr><tr><td>27</td><td>00011011</td><td>(escape)</td><td>59</td><td>00111011</td><td><code>;</code></td></tr><tr><td>28</td><td>00011100</td><td>(&ndash;)</td><td>60</td><td>00111100</td><td><code>&lt;</code></td></tr><tr><td>29</td><td>00011101</td><td>(&ndash;)</td><td>61</td><td>00111101</td><td><code>=</code></td></tr><tr><td>30</td><td>00011110</td><td>(&ndash;)</td><td>62</td><td>00111110</td><td><code>></code></td></tr><tr><td>31</td><td>00011111</td><td>(&ndash;)</td><td>63</td><td>00111111</td><td><code>?</code></td></tr></tbody></table></div><div class=col50><table><thead><tr><th>num</th><th>binary</th><th>meaning</th><th>num</th><th>binary</th><th>meaning</th></tr></thead><tbody><tr><td>64</td><td>01000000</td><td><code>@</code></td><td>96</td><td>01000000</td><td>```</td></tr><tr><td>65</td><td>01000001</td><td><code>A</code></td><td>97</td><td>01000001</td><td><code>a</code></td></tr><tr><td>66</td><td>01000010</td><td><code>B</code></td><td>98</td><td>01000010</td><td><code>b</code></td></tr><tr><td>67</td><td>01000011</td><td><code>C</code></td><td>99</td><td>01000011</td><td><code>c</code></td></tr><tr><td>68</td><td>01000100</td><td><code>D</code></td><td>100</td><td>01000100</td><td><code>d</code></td></tr><tr><td>69</td><td>01000101</td><td><code>E</code></td><td>101</td><td>01000101</td><td><code>e</code></td></tr><tr><td>70</td><td>01000110</td><td><code>F</code></td><td>102</td><td>01000110</td><td><code>f</code></td></tr><tr><td>71</td><td>01000111</td><td><code>G</code></td><td>103</td><td>01000111</td><td><code>g</code></td></tr><tr><td>72</td><td>01001000</td><td><code>H</code></td><td>104</td><td>01001000</td><td><code>h</code></td></tr><tr><td>73</td><td>01001001</td><td><code>I</code></td><td>105</td><td>01001001</td><td><code>i</code></td></tr><tr><td>74</td><td>01001010</td><td><code>J</code></td><td>106</td><td>01001010</td><td><code>j</code></td></tr><tr><td>75</td><td>01001011</td><td><code>K</code></td><td>107</td><td>01001011</td><td><code>k</code></td></tr><tr><td>76</td><td>01001100</td><td><code>L</code></td><td>108</td><td>01001100</td><td><code>l</code></td></tr><tr><td>77</td><td>01001101</td><td><code>M</code></td><td>109</td><td>01001101</td><td><code>m</code></td></tr><tr><td>78</td><td>01001110</td><td><code>N</code></td><td>110</td><td>01001110</td><td><code>n</code></td></tr><tr><td>79</td><td>01001111</td><td><code>O</code></td><td>111</td><td>01001111</td><td><code>o</code></td></tr><tr><td>80</td><td>01010000</td><td><code>P</code></td><td>112</td><td>01010000</td><td><code>p</code></td></tr><tr><td>81</td><td>01010001</td><td><code>Q</code></td><td>113</td><td>01010001</td><td><code>q</code></td></tr><tr><td>82</td><td>01010010</td><td><code>R</code></td><td>114</td><td>01010010</td><td><code>r</code></td></tr><tr><td>83</td><td>01010011</td><td><code>S</code></td><td>115</td><td>01010011</td><td><code>s</code></td></tr><tr><td>84</td><td>01010100</td><td><code>T</code></td><td>116</td><td>01010100</td><td><code>t</code></td></tr><tr><td>85</td><td>01010101</td><td><code>U</code></td><td>117</td><td>01010101</td><td><code>u</code></td></tr><tr><td>86</td><td>01010110</td><td><code>V</code></td><td>118</td><td>01010110</td><td><code>v</code></td></tr><tr><td>87</td><td>01010111</td><td><code>W</code></td><td>119</td><td>01010111</td><td><code>w</code></td></tr><tr><td>88</td><td>01011000</td><td><code>X</code></td><td>120</td><td>01011000</td><td><code>x</code></td></tr><tr><td>89</td><td>01011001</td><td><code>Y</code></td><td>121</td><td>01011001</td><td><code>y</code></td></tr><tr><td>90</td><td>01011010</td><td><code>Z</code></td><td>122</td><td>01011010</td><td><code>z</code></td></tr><tr><td>91</td><td>01011011</td><td><code>[</code></td><td>123</td><td>01011011</td><td><code>{</code></td></tr><tr><td>92</td><td>01011100</td><td><code>\</code></td><td>124</td><td>01011100</td><td>(pipe)</td></tr><tr><td>93</td><td>01011101</td><td><code>]</code></td><td>125</td><td>01011101</td><td><code>}</code></td></tr><tr><td>94</td><td>01011110</td><td><code>^</code></td><td>126</td><td>01011110</td><td><code>~</code></td></tr><tr><td>95</td><td>01011111</td><td><code>_</code></td><td>127</td><td>01011111</td><td><code>DEL</code></td></tr></tbody></table></div></div><h2 id=arrays-and-sequences>Arrays and sequences</h2><p>error replacing &ldquo;arrays/sort/default_library_sort.cpp&rdquo;</p><h3 id=counting-sort>Counting sort</h3><p><em>Description:</em> Linear stable sorting for the case where elements values range from $0$ to $M$.</p><p><em>Time:</em> $O(N+M)$, $N$ array size, $M$ elements universe</p><p>arrays/sort/counting_sort.cpp,csort</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>counting_sort</span>(vector<span style=color:#f92672>&lt;</span>ll<span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>a){
</span></span><span style=display:flex><span>	ll M <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>max_element(a.begin(), a.end())<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>	ll N <span style=color:#f92672>=</span> a.size();
</span></span><span style=display:flex><span>	vector<span style=color:#f92672>&lt;</span>ll<span style=color:#f92672>&gt;</span> c(M), r(N);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> (ll i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span>N; <span style=color:#f92672>++</span>i) <span style=color:#f92672>++</span>c[a[i]];
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> (ll i<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>; i<span style=color:#f92672>&lt;</span>M; <span style=color:#f92672>++</span>i) c[i] <span style=color:#f92672>+=</span> c[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> (ll i<span style=color:#f92672>=</span>N<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; i<span style=color:#f92672>&gt;=</span><span style=color:#ae81ff>0</span>; <span style=color:#f92672>--</span>i) r[<span style=color:#f92672>--</span>c[a[i]]] <span style=color:#f92672>=</span> a[i];
</span></span><span style=display:flex><span>	a <span style=color:#f92672>=</span> r;
</span></span><span style=display:flex><span>}</span></span></code></pre></div><h2 id=searches>Searches</h2><div class=multicols><div class=col50><p><em>Description:</em> Low is one above FALSE, high is on TRUE.</p><p>arrays/search/search_binary.cpp,lsearch</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>ll <span style=color:#a6e22e>bsearch</span>(ll low, ll high, <span style=color:#66d9ef>bool</span>(<span style=color:#f92672>*</span>cmp)(ll)){
</span></span><span style=display:flex><span>	ll mid;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span> (low <span style=color:#f92672>&lt;</span> high) {
</span></span><span style=display:flex><span>		mid <span style=color:#f92672>=</span> (low<span style=color:#f92672>+</span>high)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (cmp(mid)) high <span style=color:#f92672>=</span> mid;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>else</span>          low <span style=color:#f92672>=</span> mid<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> low;
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><div class=col50><p><em>Description:</em> A variant for floating point values.</p><p>arrays/search/search_binary.cpp,dsearch</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>ld <span style=color:#a6e22e>bsearch</span>(ld low, ld high, <span style=color:#66d9ef>bool</span>(<span style=color:#f92672>*</span>cmp)(ld)){
</span></span><span style=display:flex><span>	ld mid;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span> (low <span style=color:#f92672>&lt;</span> high<span style=color:#f92672>-</span>EPS) {
</span></span><span style=display:flex><span>		mid <span style=color:#f92672>=</span> (low<span style=color:#f92672>+</span>high)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (cmp(mid)) high <span style=color:#f92672>=</span> mid;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>else</span>          low <span style=color:#f92672>=</span> mid<span style=color:#f92672>+</span>EPS;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> mid;
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div></div><p>arrays/search/search_binary.cpp,comp</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// example comparison function
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>comp</span>(ll val){
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> (val<span style=color:#f92672>*</span>(val<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>))<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>&gt;=</span> M;
</span></span><span style=display:flex><span>}</span></span></code></pre></div><div class=multicols><div class=col50><p>arrays/search/search_ternary.cpp,ternary</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>ll <span style=color:#a6e22e>ternary</span>(ll mn, ll mx, ll(<span style=color:#f92672>*</span>getVal)(ll)){
</span></span><span style=display:flex><span>	ll low<span style=color:#f92672>=</span>mn, high<span style=color:#f92672>=</span>mx, lm, hm, last<span style=color:#f92672>=</span>INF;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span> (true) {
</span></span><span style=display:flex><span>		lm <span style=color:#f92672>=</span> low<span style=color:#f92672>+</span>(high<span style=color:#f92672>-</span>low)<span style=color:#f92672>/</span><span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>		hm <span style=color:#f92672>=</span> low<span style=color:#f92672>+</span>(high<span style=color:#f92672>-</span>low)<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>/</span><span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (lm <span style=color:#f92672>&gt;=</span> hm) <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (getVal(lm) <span style=color:#f92672>&lt;</span> getVal(hm)) {
</span></span><span style=display:flex><span>			high <span style=color:#f92672>=</span> hm;
</span></span><span style=display:flex><span>		} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>			low <span style=color:#f92672>=</span> lm<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		last <span style=color:#f92672>=</span> lm;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> low;
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><div class=col50><p>arrays/search/search_ternary.cpp,dternary</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>ld <span style=color:#a6e22e>ternary</span>(ld mn, ld mx, ld(<span style=color:#f92672>*</span>getVal)(ld)){
</span></span><span style=display:flex><span>	ld low<span style=color:#f92672>=</span>mn, high<span style=color:#f92672>=</span>mx, lm, hm, last<span style=color:#f92672>=</span>INF;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span> (true) {
</span></span><span style=display:flex><span>		lm <span style=color:#f92672>=</span> low<span style=color:#f92672>+</span>(high<span style=color:#f92672>-</span>low)<span style=color:#f92672>/</span><span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>		hm <span style=color:#f92672>=</span> low<span style=color:#f92672>+</span>(high<span style=color:#f92672>-</span>low)<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>/</span><span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (lm <span style=color:#f92672>&gt;=</span> hm) <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (getVal(lm) <span style=color:#f92672>&lt;</span> getVal(hm)) {
</span></span><span style=display:flex><span>			high <span style=color:#f92672>=</span> hm<span style=color:#f92672>-</span>EPS;
</span></span><span style=display:flex><span>		} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>			low <span style=color:#f92672>=</span> lm<span style=color:#f92672>+</span>EPS;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		last <span style=color:#f92672>=</span> lm;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> low;
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div></div><h3 id=offline-array-sum-queries>Offline array sum queries</h3><p><em>Description:</em> Preprocess array to quickly answer sum queries for numbers from <code>f</code> (inclusive) to <code>t</code> (exclusive). The prefix sum <code>d</code> contains on <code>i</code> sums of elments on indices smaller than <code>i</code>.</p><p><em>Time:</em> prepare $O(N)$, sum $O(1)$</p><p>arrays/array_sum.cpp,array_sum</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#define MX 1000004
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>ll d[MX];
</span></span><span style=display:flex><span>ll <span style=color:#a6e22e>sum</span>(ll f, ll t){
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> d[t] <span style=color:#f92672>-</span> d[f];
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>prepare</span>(ll N){
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span>(ll x<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>; x<span style=color:#f92672>&lt;=</span>N; <span style=color:#f92672>++</span>x) d[x] <span style=color:#f92672>+=</span> d[x<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>}</span></span></code></pre></div><h3 id=fenwick-tree>Fenwick tree</h3><p><em>Description:</em> Quick update of single elements and range sum queries.</p><p><em>Time:</em> $O(\log n)$ update, $O(\log n)$ prefsum, (optional) $O(n)$ create (alt. insert one by one)</p><p>data_structures/fenwick.cpp,fenwick</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#define lsb(n) (n &amp; -n)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Fenwick</span>{
</span></span><span style=display:flex><span>	vector<span style=color:#f92672>&lt;</span>ll<span style=color:#f92672>&gt;</span> fw;
</span></span><span style=display:flex><span>	Fenwick(ll N) <span style=color:#f92672>:</span> fw(N<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>0</span>) {};
</span></span><span style=display:flex><span>	ll <span style=color:#a6e22e>prefsum</span>(ll n) { <span style=color:#75715e>// exclusive
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		ll sum <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>while</span> (n <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>			sum <span style=color:#f92672>+=</span> fw[n];
</span></span><span style=display:flex><span>			n <span style=color:#f92672>-=</span> lsb(n);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> sum;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>update</span>(ll n, ll v) {
</span></span><span style=display:flex><span>		n<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>while</span> (n <span style=color:#f92672>&lt;=</span> fw.size()) {
</span></span><span style=display:flex><span>			fw[n] <span style=color:#f92672>+=</span> v;
</span></span><span style=display:flex><span>			n <span style=color:#f92672>+=</span> lsb(n);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#75715e>// optional functions below
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	ll <span style=color:#a6e22e>sum_range</span>(ll i, ll j) { <span style=color:#75715e>// inclusive
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>return</span> prefsum(j<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>) <span style=color:#f92672>-</span> prefsum(i);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	Fenwick(vector<span style=color:#f92672>&lt;</span>ll<span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>a) <span style=color:#f92672>:</span> fw(a.size()<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span>(ll i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span>a.size(); <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>			fw[i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>]<span style=color:#f92672>=</span>a[i];
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span>(ll i<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>; i<span style=color:#f92672>&lt;</span>a.size()<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>; <span style=color:#f92672>++</span>i){
</span></span><span style=display:flex><span>			ll p <span style=color:#f92672>=</span> i<span style=color:#f92672>+</span>lsb(i);
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> (p <span style=color:#f92672>&lt;=</span> fw.size()) {
</span></span><span style=display:flex><span>				fw[p] <span style=color:#f92672>+=</span> fw[i];
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>};</span></span></code></pre></div><p>Fenwick can be used to keep sorted set of small elements with $O(\log n)$ add and remove (direct indexing, change value by +1/-1), with $O(\log^2 n)$ query (binary search the position).</p><h3 id=lowest-common-ancestor-lca>Lowest common ancestor (LCA)</h3><p><em>Description:</em> Given tree structure (by the list of parents where the root loops) allows queries answering lowest common ancestor. Gives -1 for distinct trees.</p><p><em>Time:</em> create $O(N \log N)$, queries $O(\log N)$</p><p>data_structures/lca.cpp,lca</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>ll LOG<span style=color:#f92672>=</span><span style=color:#ae81ff>30</span>; <span style=color:#75715e>// must be more than log2(par.size())
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>LCA</span> {
</span></span><span style=display:flex><span>	ll N;
</span></span><span style=display:flex><span>	vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span>ll<span style=color:#f92672>&gt;&gt;</span> dp; <span style=color:#75715e>// binary lifting
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	vector<span style=color:#f92672>&lt;</span>ll<span style=color:#f92672>&gt;</span> depth; <span style=color:#75715e>// depth
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	LCA(vector<span style=color:#f92672>&lt;</span>ll<span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>par) <span style=color:#f92672>:</span> N(par.size()),
</span></span><span style=display:flex><span>	depth(N, <span style=color:#ae81ff>1</span>), dp(N, vector<span style=color:#f92672>&lt;</span>ll<span style=color:#f92672>&gt;</span>(LOG, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> (ll i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span>N; <span style=color:#f92672>++</span>i) dp[i][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> par[i];
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> (ll j<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>; j<span style=color:#f92672>&lt;</span>LOG; <span style=color:#f92672>++</span>j) {
</span></span><span style=display:flex><span>			vector<span style=color:#f92672>&lt;</span>ll<span style=color:#f92672>&gt;</span> tmp<span style=color:#f92672>=</span>depth;
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>for</span> (ll i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span>N; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>				dp[i][j] <span style=color:#f92672>=</span> dp[dp[i][j<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]][j<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> (dp[i][j]<span style=color:#f92672>!=</span>dp[i][j<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]) {
</span></span><span style=display:flex><span>					depth[i] <span style=color:#f92672>+=</span> tmp[dp[i][j<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]];
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span>(ll i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span>N; <span style=color:#f92672>++</span>i){
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span>(dp[i][<span style=color:#ae81ff>0</span>]<span style=color:#f92672>==</span>i)<span style=color:#f92672>--</span>depth[i];
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	ll <span style=color:#a6e22e>lca</span>(ll p, ll q) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (depth[p] <span style=color:#f92672>&lt;</span> depth[q]) swap(p, q);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span>(ll i<span style=color:#f92672>=</span>LOG<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; i<span style=color:#f92672>&gt;=</span><span style=color:#ae81ff>0</span>; <span style=color:#f92672>--</span>i){
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> (depth[p] <span style=color:#f92672>-</span> (<span style=color:#ae81ff>1</span><span style=color:#f92672>&lt;&lt;</span>i) <span style=color:#f92672>&gt;=</span> depth[q]){
</span></span><span style=display:flex><span>				p <span style=color:#f92672>=</span> dp[p][i];
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (p<span style=color:#f92672>==</span>q) <span style=color:#66d9ef>return</span> p;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (dp[p][LOG<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>!=</span> dp[q][LOG<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]) {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; <span style=color:#75715e>// if we allow forests
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span>(ll i<span style=color:#f92672>=</span>LOG<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; i<span style=color:#f92672>&gt;=</span><span style=color:#ae81ff>0</span>; <span style=color:#f92672>--</span>i){
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> (dp[p][i] <span style=color:#f92672>!=</span> dp[q][i]){
</span></span><span style=display:flex><span>				p <span style=color:#f92672>=</span> dp[p][i];
</span></span><span style=display:flex><span>				q <span style=color:#f92672>=</span> dp[q][i];
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> dp[p][<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>};</span></span></code></pre></div><div class=multicols><div class=col50><h3 id=dynamic-programming>Dynamic programming</h3><p><em>Description:</em> A generic approach to applying function result memorization. Its application turns this example into the next one.</p><p>data_structures/dynamic_programming.cpp,basis</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>ll <span style=color:#a6e22e>fac</span>(ll a, ll b){
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (a <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>3</span> <span style=color:#f92672>||</span> b <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>3</span>) <span style=color:#66d9ef>return</span> a<span style=color:#f92672>+</span>b;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> fac(a<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, b) <span style=color:#f92672>+</span> fac(a, b<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><div class=col50><p>data_structures/dynamic_programming.cpp,dp</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>map<span style=color:#f92672>&lt;</span>tuple<span style=color:#f92672>&lt;</span>ll,ll<span style=color:#f92672>&gt;</span>,ll<span style=color:#f92672>&gt;</span> dp;
</span></span><span style=display:flex><span>ll <span style=color:#a6e22e>fac</span>(ll a, ll b){
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>auto</span> res <span style=color:#f92672>=</span> dp.find({a,b});
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span>(res <span style=color:#f92672>!=</span> dp.end()) <span style=color:#66d9ef>return</span> res<span style=color:#f92672>-&gt;</span>second;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (a <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>3</span> <span style=color:#f92672>||</span> b <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>3</span>) <span style=color:#66d9ef>return</span> dp[{a,b}] <span style=color:#f92672>=</span> a<span style=color:#f92672>+</span>b;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> dp[{a,b}] <span style=color:#f92672>=</span> fac(a<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, b) <span style=color:#f92672>+</span> fac(a, b<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div></div></main><footer><span></span></footer></body></html>